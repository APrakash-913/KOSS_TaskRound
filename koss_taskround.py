# -*- coding: utf-8 -*-
"""KOSS_taskRound.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1B2k0W-yDizBo8ghgJqES-ebfQhe-Jiip

# Asynchronous Execution
the concurrent.futures module provide a high-level interface for asynchronously executing callables.
Asynchronous Execution can be perfromed via.
  1. threads -> ThreadPoolExecutor (I/O bound tasks)
  2. Seperate Processes -> ProcessPoolExecutor (CPU bound tasks)

# ThreadPoolExecutor
"""

# Launching parallel task (by using threads)
# concurrent.futures
import time
from concurrent.futures import ThreadPoolExecutor # there is also ProcessPoolExecutor

def return_num(a):
  time.sleep(1) # assuming it as a dataframe that take 1 sec to return a (some kind of complex model) -> done so to how how thread are working
  return a

return_num(12)

# lets use "ThreadPoolExecutor" to run above fn parallely
start = time.time()
with ThreadPoolExecutor(max_workers=None) as executor: # providing reference variable to ALL MAX_WORKERS as "executor".
  for result in executor.map(return_num, range(100)): # as each and every thread executes "return_num" -> it will return no. by iterating through the entire range i.e. 0 to 99
    # this "executor" will be a list -> containing ref. of Threads

    print("Count: {0}".format(result)) # Simple String formatting
# jotting TIME LAPSE
print("The total time is: {0}".format(time.time()-start))
# // we didn't see any kind of parallelism / Asynchronous thing
# max_workers --> defines no. of parallel task you want to perform.(Simply put ==> No. of THREADS)

"""# Working
By setting max_workers = 5, you will witness that 5 threads are created at a every execution and 5 threads are executing this fn simultaneously.
"""

# lets declare thread :)
start = time.time()
with ThreadPoolExecutor(max_workers=5) as executor: # providing reference variable to ALL MAX_WORKERS as "executor".
  for result in executor.map(return_num, range(100)): # as each and every thread executes "return_num" -> it will return no. by iterating through the entire range i.e. 0 to 99
    # this "executor" will be a list -> containing ref. of Threads

    print("Count: {0}".format(result)) # Simple String formatting
# jotting TIME LAPSE
print("The total time is: {0}".format(time.time()-start))

"""#ProcessPoolExecutor"""

import time
sec0 = [5, 4, 3, 2, 1]
starter = time.time()

def do0():
  for a in sec0:
    print(f"Yo {a} secs")
    time.sleep(a)
    # print("Bye")
    print(f'Bye {a} secs')
do0()
ender = time.time()
print(f'Total time = {ender - starter}')

# modern way
import concurrent.futures

start = time.time()
def do1(a):
  print(f"Yo {a} secs")
  time.sleep(a)
  # print("Bye")
  return f'Bye {a} secs'

with concurrent.futures.ProcessPoolExecutor(max_workers= 5) as executor:
  secs = [5, 4, 3, 2, 1]
  # secs = [1]*10
  for result in executor.map(do1, secs):
    print(result)
  # results = [executor.submit(do1, sec) for sec in secs] # onr can use regular loop

  # for f in concurrent.futures.as_completed(results):
  #   print(f.result())

  # f1 = executor.submit(do1, 1)# 1 -> argument that is passed to fn "do1". 
  #                             # submit -> if we want to execute fn 1 at a time. And return a future object
  # print(f1.result())

end = time.time()
print(f'Total time = {end - start}')